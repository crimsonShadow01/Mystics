void AlphaTest( float alpha, float threshold )
{
    {% hd %}
        {% if pass.name == "Forward" or pass.name == "GBuffer" %}
            #if defined(SHADERPASS_FORWARD_BYPASS_ALPHA_TEST) \
                || defined(SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST)
                // Ignore clip in forward and gbuffer passes. We already did the clip in the Depth Prepass, and we use ZTest Equal for this pass to discard the transparent pixels.
            #else
                clip( alpha - threshold );
            #endif
        {% else %}
            clip( alpha - threshold );
        {% endif %}
    {% endhd %}
    {% standard or universal %}
        clip( alpha - threshold );
    {% endstandard %}
}

{% if wind %}
void GetFade(
    float3 objectPivot, // The object pivot in world space.
    out float windFade, 
    out float scaleFade )
{
    #if defined(_TYPE_TREE_LEAVES) || defined(_TYPE_TREE_BARK)
        windFade = 1.0;
        scaleFade = 1.0;
    #else
        float distanceToCamera = distance( objectPivot, _WorldSpaceCameraPos );
        windFade = 1.0 - saturate( (distanceToCamera - _WindFade.x) / _WindFade.y );
        scaleFade = 1.0 - saturate( (distanceToCamera - _ScaleFade.x) / _ScaleFade.y  );
    #endif
}
{% endif %}

{% if fade %}
    void PerVertexFade( float3 objectPivot, out float windFade, out float scaleFade )
    {
        #ifdef PER_OBJECT_VALUES_CALCULATED
            windFade = g_WindFade;
            scaleFade = g_ScaleFade;
        #else
            GetFade( 
                objectPivot,
                windFade,
                scaleFade );
        #endif
    }
{% endif %}

{% if wind %}
    void Wind(
        inout VertexAttributes vertex,
        inout SurfaceInput surface,
        inout float3 positionWS,
        float windFade,
        float scaleFade,
        float heightMask,
        float phaseOffset,
        float3 objectPivot )
    {
        WindInput input;

        // Global
        input.direction = GetWindDirection();
        input.speed = GetWindSpeed();

        // Per-Object
        input.objectPivot = objectPivot;
        input.fade = windFade;

        // Per-Vertex
        input.phaseOffset = phaseOffset;
        input.normalWS = surface.normalWS;
        float windVariation = GetWindVariation( input.objectPivot );
        float vertexMask = GetVertexMask( vertex.color );
        input.mask =  heightMask * vertexMask * windVariation;
        input.flutter = GetEdgeFlutter( vertex.color );

        float3 vertexOut = positionWS;
        float3 normalOut = surface.normalWS;
        Wind( 
            input,
            vertexOut, 
            normalOut );

        #if defined(_TYPE_TREE_LEAVES) || defined( _TYPE_TREE_BARK )
            Wind_Trunk( 
                vertex.positionOS.xyz, 
                positionWS.xyz, 
                vertexOut.xyz, 
                vertex.uv1.xy, 
                input.objectPivot, 
                input.direction, 
                vertexOut );
        #endif

        positionWS = vertexOut;
        surface.normalWS = normalOut;
    }
{% endif %}

float PerVertexPerlinNoise( float3 objectPivot )
{
    #ifdef PER_OBJECT_VALUES_CALCULATED
        return g_WorldNoise;
    #else
        float noise;
        PerlinNoise_float( objectPivot.xz, _ColorVariationSpread, noise );
        return noise;
    #endif
}

{% if fade %}
    float3 ApplyScaleFade( 
        float3 vertexWorldPosition, float3 objectPivot, float fade )
    {
        vertexWorldPosition.y = lerp(objectPivot.y, vertexWorldPosition.y, max(fade, 0.2));
        return vertexWorldPosition;
    }
{% endif %}

// Surface

void SampleAlbedo( float2 uv0, out float4 albedo )
{
    albedo = UNITY_SAMPLE_TEX2D_SAMPLER( _Albedo, _Albedo, uv0 );
}

void ApplyColorCorrection( inout float4 albedo, float noise )
{
    #ifdef _COLOR_HSL
        float4 albedo1 = albedo;
        float4 albedo2 = albedo;
        HSL_float( albedo1, _HSL, albedo1 );
        HSL_float( albedo2, _HSLVariation, albedo2 );
        albedo = lerp(albedo2, albedo1, noise);
    #else
        albedo *= lerp(_TintVariation, _Tint, noise);
    #endif
}

#ifdef _NORMALMAP
    void SampleNormalMap( float2 uv0, out float3 normal )
    {
        normal = 
            UnpackScaleNormal( 
                UNITY_SAMPLE_TEX2D_SAMPLER( _NormalMap, _NormalMap, uv0 ), _NormalMapScale ).xyz;
    }
#endif

{% if surface_map %}
    #ifdef _SURFACE_MAP_PACKED
        void SamplePackedMap(
            float2 uv0, out float metallic, out float smoothness, out float occlusion)
        {
            float4 packed = UNITY_SAMPLE_TEX2D_SAMPLER(_PackedMap, _PackedMap, uv0);
            metallic = packed.r;
            smoothness = Remap(packed.a, _GlossRemap);
            occlusion = Remap(packed.g, _OcclusionRemap);
        }
    #endif

    #ifdef _SURFACE_MAP_METALLIC_GLOSS
        void SampleMetallicGlossMap(
            float2 uv0, out float metallic, out float smoothness, out float occlusion)
        {
            float4 metallicGloss = UNITY_SAMPLE_TEX2D_SAMPLER( _MetallicGlossMap, _MetallicGlossMap, uv0 );
            metallic = metallicGloss.r;
            smoothness = Remap(metallicGloss.a, _GlossRemap);
            occlusion = Remap(UNITY_SAMPLE_TEX2D_SAMPLER( _OcclusionMap, _OcclusionMap, uv0 ).g, _OcclusionRemap);
        }
    #endif
{% endif %}

void SampleMetallicGlossConstants(
    float2 uv0, out float metallic, out float smoothness, out float occlusion)
{
    metallic = _Metallic;
    smoothness = _Glossiness;
    occlusion = 1;
}

{% if translucent %}
    #ifdef _TRANSLUCENCY
        void SampleThickness( float2 uv0, out float thickness )
        {
            thickness = UNITY_SAMPLE_TEX2D_SAMPLER( _ThicknessMap, _ThicknessMap, uv0 ).r;
            thickness = Remap( thickness, _ThicknessRemap );
        }
    #endif
{% endif %}

{% if emission %}
    #ifdef _EMISSION
        void SampleEmission( float2 uv0, out float3 emission )
        {
            emission = UNITY_SAMPLE_TEX2D_SAMPLER( _EmissionMap, _EmissionMap, uv0 ).rgb;
            emission *= _EmissionColor.rgb;
            emission *= _EmissionIntensity;
        }
    #endif
{% endif %}

{% if double_sided %}
    void FlipNormals( inout float3 normals, FRONT_FACE_TYPE cullFace )
    {
        normals.z *=
            _DoubleSidedNormalMode > 0 
                ? IS_FRONT_VFACE(cullFace, 1, -1) 
                : 1.0;
    }
{% endif %}